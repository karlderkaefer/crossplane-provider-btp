/*
SaaS Provisioning Service

The SAP SaaS Provisioning service provides REST APIs that are responsible for the registration and provisioning of multitenant applications and services.   Use the APIs in this service to perform various operations related to your multitenant applications and services. For example, to get application registration details, subscribe a tenant to your application, unsubscribe a tenant from your application, retrieve all your application subscriptions, update subscription dependencies, and to get subscription job information. Note: \"Application Operations for App Providers\" APIs are intended for maintenance activities, not for runtime flows.  See also: * [Authorization](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/3670474a58c24ac2b082e76cbbd9dc19.html) * [Rate Limiting](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77b217b3f57a45b987eb7fbc3305ce1e.html) * [Error Response Format](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77fef2fb104b4b1795e2e6cee790e8b8.html) * [Asynchronous Jobs](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/0a0a6ab0ad114d72a6611c1c6b21683e.html)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SubscriptionOperationsForAppConsumersAPI interface {

	/*
	CreateSubscriptionAsync Subscribe to an application from a subaccount

	Subscribe to a multitenant application from a subaccount.
This process is asynchronous.
You must be assigned to the subaccount admin role.
To check which multitenant applications the subaccount can subscribe to, use the API: GET /saas-manager/v1/applications.<br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to subscribe to.
	@return ApiCreateSubscriptionAsyncRequest
	*/
	CreateSubscriptionAsync(ctx context.Context, appName string) ApiCreateSubscriptionAsyncRequest

	// CreateSubscriptionAsyncExecute executes the request
	CreateSubscriptionAsyncExecute(r ApiCreateSubscriptionAsyncRequest) (*http.Response, error)

	/*
	DeleteSubscriptionAsync Unsubscribe an application from a subaccount

	Unsubscribe a multitenant application from a subaccount. This process is asynchronous. All data related to the subscribed multitenant application will be deleted in the respective subaccount. To show all application entitlements, including application names, plan names, and subscription status, in a subaccount, use GET /saas-manager/v1/applications/{appName} <br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application from which to unsubscribe the subaccount.
	@return ApiDeleteSubscriptionAsyncRequest
	*/
	DeleteSubscriptionAsync(ctx context.Context, appName string) ApiDeleteSubscriptionAsyncRequest

	// DeleteSubscriptionAsyncExecute executes the request
	DeleteSubscriptionAsyncExecute(r ApiDeleteSubscriptionAsyncRequest) (*http.Response, error)

	/*
	DeleteSubscriptionLabels Remove all labels from a multitenant application subscription

	Remove all user-defined labels that are assigned to a consumer subaccount's subscription to a multitenant application. 

To remove specific labels, use instead: PUT /saas-manager/v1/applications/{appName}/ subscription/labels
Required scope: $XSAPPNAME.subaccount.application.subscription.update 


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to which a subaccount is subscribed.
	@return ApiDeleteSubscriptionLabelsRequest
	*/
	DeleteSubscriptionLabels(ctx context.Context, appName string) ApiDeleteSubscriptionLabelsRequest

	// DeleteSubscriptionLabelsExecute executes the request
	//  @return map[string]interface{}
	DeleteSubscriptionLabelsExecute(r ApiDeleteSubscriptionLabelsRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetEntitledApplication Get details of a multitenant application

	Get details of a specific multitenant application to which the subaccount is entitled to subscribe. Also useful for finding the URL to launch the application.<br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to which a subaccount is entitled to subscribe.
	@return ApiGetEntitledApplicationRequest
	*/
	GetEntitledApplication(ctx context.Context, appName string) ApiGetEntitledApplicationRequest

	// GetEntitledApplicationExecute executes the request
	//  @return EntitledApplicationsResponseObject
	GetEntitledApplicationExecute(r ApiGetEntitledApplicationRequest) (*EntitledApplicationsResponseObject, *http.Response, error)

	/*
	GetEntitledApplications Get all entitled multitenant applications

	List all the multitenant applications to which a subaccount is entitled to subscribe, including their subscription details. Also useful for finding the URLs to launch each of the entitled applications.<br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEntitledApplicationsRequest
	*/
	GetEntitledApplications(ctx context.Context) ApiGetEntitledApplicationsRequest

	// GetEntitledApplicationsExecute executes the request
	//  @return EntitledApplicationsResponseCollection
	GetEntitledApplicationsExecute(r ApiGetEntitledApplicationsRequest) (*EntitledApplicationsResponseCollection, *http.Response, error)

	/*
	GetSubscriptionLabels Get labels for a multitenant application subscription

	Get all the user-defined labels that are assigned as key-value pairs to a consumer subaccount's subscription to a multitenant application. 

Required scope: $XSAPPNAME.subaccount.application.subscription.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to which a subaccount is subscribed.
	@return ApiGetSubscriptionLabelsRequest
	*/
	GetSubscriptionLabels(ctx context.Context, appName string) ApiGetSubscriptionLabelsRequest

	// GetSubscriptionLabelsExecute executes the request
	//  @return map[string]interface{}
	GetSubscriptionLabelsExecute(r ApiGetSubscriptionLabelsRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetSubscriptionParams Get subscription parameters

	Get all user-defined consumer subaccount's subscription parameters to a multitenant application. 

Required scope: $XSAPPNAME.subaccount.application.subscription.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to which a subaccount is subscribed.
	@return ApiGetSubscriptionParamsRequest
	*/
	GetSubscriptionParams(ctx context.Context, appName string) ApiGetSubscriptionParamsRequest

	// GetSubscriptionParamsExecute executes the request
	//  @return map[string]interface{}
	GetSubscriptionParamsExecute(r ApiGetSubscriptionParamsRequest) (map[string]interface{}, *http.Response, error)

	/*
	UpdateSubscriptionParametersAsync Update parameters of a multitenant application subscription

	Change the parameters of an existing subscription to a multitenant application. For example, you can change the application plan in a subscription. To update subscription parameters, the subaccount must already be subscribed to the application. <br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to update.
	@return ApiUpdateSubscriptionParametersAsyncRequest
	*/
	UpdateSubscriptionParametersAsync(ctx context.Context, appName string) ApiUpdateSubscriptionParametersAsyncRequest

	// UpdateSubscriptionParametersAsyncExecute executes the request
	UpdateSubscriptionParametersAsyncExecute(r ApiUpdateSubscriptionParametersAsyncRequest) (*http.Response, error)

	/*
	UpsertSubscriptionLabels Assign labels to a multitenant application subscription

	Assign user-defined labels to a consumer subaccount's subscription to a multitenant application. Labels are specified as key-value pairs. 

Required scope: $XSAPPNAME.subaccount.application.subscription.update


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param appName The name of the multitenant application to which a subaccount is subscribed.
	@return ApiUpsertSubscriptionLabelsRequest
	*/
	UpsertSubscriptionLabels(ctx context.Context, appName string) ApiUpsertSubscriptionLabelsRequest

	// UpsertSubscriptionLabelsExecute executes the request
	//  @return map[string]interface{}
	UpsertSubscriptionLabelsExecute(r ApiUpsertSubscriptionLabelsRequest) (map[string]interface{}, *http.Response, error)
}

// SubscriptionOperationsForAppConsumersAPIService SubscriptionOperationsForAppConsumersAPI service
type SubscriptionOperationsForAppConsumersAPIService service

type ApiCreateSubscriptionAsyncRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	useCommercialAppName *bool
	sAPPASSPORT *string
	createSubscriptionRequestPayload *CreateSubscriptionRequestPayload
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiCreateSubscriptionAsyncRequest) UseCommercialAppName(useCommercialAppName bool) ApiCreateSubscriptionAsyncRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

// Provide a set of correlation parameters to be used by the initial and subsequent components involved in the request:  - The Root Context ID (GUID) identifies the initial context within a complex scenario, for example, the initiating user session.  - The Transaction ID (GUID) identifies a technical transaction.  - Connection ID (GUID) and Connection Counter uniquely identify together  every request or message leaving a component via outbound communication.
func (r ApiCreateSubscriptionAsyncRequest) SAPPASSPORT(sAPPASSPORT string) ApiCreateSubscriptionAsyncRequest {
	r.sAPPASSPORT = &sAPPASSPORT
	return r
}

func (r ApiCreateSubscriptionAsyncRequest) CreateSubscriptionRequestPayload(createSubscriptionRequestPayload CreateSubscriptionRequestPayload) ApiCreateSubscriptionAsyncRequest {
	r.createSubscriptionRequestPayload = &createSubscriptionRequestPayload
	return r
}

func (r ApiCreateSubscriptionAsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSubscriptionAsyncExecute(r)
}

/*
CreateSubscriptionAsync Subscribe to an application from a subaccount

Subscribe to a multitenant application from a subaccount.
This process is asynchronous.
You must be assigned to the subaccount admin role.
To check which multitenant applications the subaccount can subscribe to, use the API: GET /saas-manager/v1/applications.<br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to subscribe to.
 @return ApiCreateSubscriptionAsyncRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) CreateSubscriptionAsync(ctx context.Context, appName string) ApiCreateSubscriptionAsyncRequest {
	return ApiCreateSubscriptionAsyncRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
func (a *SubscriptionOperationsForAppConsumersAPIService) CreateSubscriptionAsyncExecute(r ApiCreateSubscriptionAsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.CreateSubscriptionAsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.sAPPASSPORT != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "SAP-PASSPORT", r.sAPPASSPORT, "simple", "")
	}
	// body params
	localVarPostBody = r.createSubscriptionRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSubscriptionAsyncRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	useCommercialAppName *bool
	sAPPASSPORT *string
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiDeleteSubscriptionAsyncRequest) UseCommercialAppName(useCommercialAppName bool) ApiDeleteSubscriptionAsyncRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

// Provide a set of correlation parameters to be used by the initial and subsequent components involved in the request:  - The Root Context ID (GUID) identifies the initial context within a complex scenario, for example, the initiating user session.  - The Transaction ID (GUID) identifies a technical transaction.  - Connection ID (GUID) and Connection Counter uniquely identify together  every request or message leaving a component via outbound communication.
func (r ApiDeleteSubscriptionAsyncRequest) SAPPASSPORT(sAPPASSPORT string) ApiDeleteSubscriptionAsyncRequest {
	r.sAPPASSPORT = &sAPPASSPORT
	return r
}

func (r ApiDeleteSubscriptionAsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSubscriptionAsyncExecute(r)
}

/*
DeleteSubscriptionAsync Unsubscribe an application from a subaccount

Unsubscribe a multitenant application from a subaccount. This process is asynchronous. All data related to the subscribed multitenant application will be deleted in the respective subaccount. To show all application entitlements, including application names, plan names, and subscription status, in a subaccount, use GET /saas-manager/v1/applications/{appName} <br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application from which to unsubscribe the subaccount.
 @return ApiDeleteSubscriptionAsyncRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) DeleteSubscriptionAsync(ctx context.Context, appName string) ApiDeleteSubscriptionAsyncRequest {
	return ApiDeleteSubscriptionAsyncRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
func (a *SubscriptionOperationsForAppConsumersAPIService) DeleteSubscriptionAsyncExecute(r ApiDeleteSubscriptionAsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.DeleteSubscriptionAsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.sAPPASSPORT != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "SAP-PASSPORT", r.sAPPASSPORT, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSubscriptionLabelsRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	useCommercialAppName *bool
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiDeleteSubscriptionLabelsRequest) UseCommercialAppName(useCommercialAppName bool) ApiDeleteSubscriptionLabelsRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

func (r ApiDeleteSubscriptionLabelsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteSubscriptionLabelsExecute(r)
}

/*
DeleteSubscriptionLabels Remove all labels from a multitenant application subscription

Remove all user-defined labels that are assigned to a consumer subaccount's subscription to a multitenant application. 

To remove specific labels, use instead: PUT /saas-manager/v1/applications/{appName}/ subscription/labels
Required scope: $XSAPPNAME.subaccount.application.subscription.update 


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to which a subaccount is subscribed.
 @return ApiDeleteSubscriptionLabelsRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) DeleteSubscriptionLabels(ctx context.Context, appName string) ApiDeleteSubscriptionLabelsRequest {
	return ApiDeleteSubscriptionLabelsRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SubscriptionOperationsForAppConsumersAPIService) DeleteSubscriptionLabelsExecute(r ApiDeleteSubscriptionLabelsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.DeleteSubscriptionLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntitledApplicationRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	planName *string
	useCommercialAppName *bool
	acceptLanguage *string
}

// The name of the subscription plan to the multitenant application.
func (r ApiGetEntitledApplicationRequest) PlanName(planName string) ApiGetEntitledApplicationRequest {
	r.planName = &planName
	return r
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiGetEntitledApplicationRequest) UseCommercialAppName(useCommercialAppName bool) ApiGetEntitledApplicationRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

// Indicates the natural language and locale that the client prefers.
func (r ApiGetEntitledApplicationRequest) AcceptLanguage(acceptLanguage string) ApiGetEntitledApplicationRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEntitledApplicationRequest) Execute() (*EntitledApplicationsResponseObject, *http.Response, error) {
	return r.ApiService.GetEntitledApplicationExecute(r)
}

/*
GetEntitledApplication Get details of a multitenant application

Get details of a specific multitenant application to which the subaccount is entitled to subscribe. Also useful for finding the URL to launch the application.<br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to which a subaccount is entitled to subscribe.
 @return ApiGetEntitledApplicationRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) GetEntitledApplication(ctx context.Context, appName string) ApiGetEntitledApplicationRequest {
	return ApiGetEntitledApplicationRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return EntitledApplicationsResponseObject
func (a *SubscriptionOperationsForAppConsumersAPIService) GetEntitledApplicationExecute(r ApiGetEntitledApplicationRequest) (*EntitledApplicationsResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntitledApplicationsResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.GetEntitledApplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.planName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "planName", r.planName, "form", "")
	}
	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntitledApplicationsRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	acceptLanguage *string
}

// Indicates the natural language and locale that the client prefers.
func (r ApiGetEntitledApplicationsRequest) AcceptLanguage(acceptLanguage string) ApiGetEntitledApplicationsRequest {
	r.acceptLanguage = &acceptLanguage
	return r
}

func (r ApiGetEntitledApplicationsRequest) Execute() (*EntitledApplicationsResponseCollection, *http.Response, error) {
	return r.ApiService.GetEntitledApplicationsExecute(r)
}

/*
GetEntitledApplications Get all entitled multitenant applications

List all the multitenant applications to which a subaccount is entitled to subscribe, including their subscription details. Also useful for finding the URLs to launch each of the entitled applications.<br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEntitledApplicationsRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) GetEntitledApplications(ctx context.Context) ApiGetEntitledApplicationsRequest {
	return ApiGetEntitledApplicationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntitledApplicationsResponseCollection
func (a *SubscriptionOperationsForAppConsumersAPIService) GetEntitledApplicationsExecute(r ApiGetEntitledApplicationsRequest) (*EntitledApplicationsResponseCollection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntitledApplicationsResponseCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.GetEntitledApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.acceptLanguage != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept-Language", r.acceptLanguage, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionLabelsRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	useCommercialAppName *bool
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiGetSubscriptionLabelsRequest) UseCommercialAppName(useCommercialAppName bool) ApiGetSubscriptionLabelsRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

func (r ApiGetSubscriptionLabelsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSubscriptionLabelsExecute(r)
}

/*
GetSubscriptionLabels Get labels for a multitenant application subscription

Get all the user-defined labels that are assigned as key-value pairs to a consumer subaccount's subscription to a multitenant application. 

Required scope: $XSAPPNAME.subaccount.application.subscription.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to which a subaccount is subscribed.
 @return ApiGetSubscriptionLabelsRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) GetSubscriptionLabels(ctx context.Context, appName string) ApiGetSubscriptionLabelsRequest {
	return ApiGetSubscriptionLabelsRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SubscriptionOperationsForAppConsumersAPIService) GetSubscriptionLabelsExecute(r ApiGetSubscriptionLabelsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.GetSubscriptionLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionParamsRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	useCommercialAppName *bool
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiGetSubscriptionParamsRequest) UseCommercialAppName(useCommercialAppName bool) ApiGetSubscriptionParamsRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

func (r ApiGetSubscriptionParamsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSubscriptionParamsExecute(r)
}

/*
GetSubscriptionParams Get subscription parameters

Get all user-defined consumer subaccount's subscription parameters to a multitenant application. 

Required scope: $XSAPPNAME.subaccount.application.subscription.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to which a subaccount is subscribed.
 @return ApiGetSubscriptionParamsRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) GetSubscriptionParams(ctx context.Context, appName string) ApiGetSubscriptionParamsRequest {
	return ApiGetSubscriptionParamsRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SubscriptionOperationsForAppConsumersAPIService) GetSubscriptionParamsExecute(r ApiGetSubscriptionParamsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.GetSubscriptionParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubscriptionParametersAsyncRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	useCommercialAppName *bool
	updateSubscriptionRequestPayload *UpdateSubscriptionRequestPayload
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiUpdateSubscriptionParametersAsyncRequest) UseCommercialAppName(useCommercialAppName bool) ApiUpdateSubscriptionParametersAsyncRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

func (r ApiUpdateSubscriptionParametersAsyncRequest) UpdateSubscriptionRequestPayload(updateSubscriptionRequestPayload UpdateSubscriptionRequestPayload) ApiUpdateSubscriptionParametersAsyncRequest {
	r.updateSubscriptionRequestPayload = &updateSubscriptionRequestPayload
	return r
}

func (r ApiUpdateSubscriptionParametersAsyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSubscriptionParametersAsyncExecute(r)
}

/*
UpdateSubscriptionParametersAsync Update parameters of a multitenant application subscription

Change the parameters of an existing subscription to a multitenant application. For example, you can change the application plan in a subscription. To update subscription parameters, the subaccount must already be subscribed to the application. <br/><br/>Required scopes: $XSAPPNAME.subaccount.application.subscription.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to update.
 @return ApiUpdateSubscriptionParametersAsyncRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) UpdateSubscriptionParametersAsync(ctx context.Context, appName string) ApiUpdateSubscriptionParametersAsyncRequest {
	return ApiUpdateSubscriptionParametersAsyncRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
func (a *SubscriptionOperationsForAppConsumersAPIService) UpdateSubscriptionParametersAsyncExecute(r ApiUpdateSubscriptionParametersAsyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.UpdateSubscriptionParametersAsync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSubscriptionRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpsertSubscriptionLabelsRequest struct {
	ctx context.Context
	ApiService SubscriptionOperationsForAppConsumersAPI
	appName string
	labelAssignmentRequestPayload *LabelAssignmentRequestPayload
	useCommercialAppName *bool
}

func (r ApiUpsertSubscriptionLabelsRequest) LabelAssignmentRequestPayload(labelAssignmentRequestPayload LabelAssignmentRequestPayload) ApiUpsertSubscriptionLabelsRequest {
	r.labelAssignmentRequestPayload = &labelAssignmentRequestPayload
	return r
}

// Whether appName is used as a commercialAppName. default is false, means it is used as the appName.
func (r ApiUpsertSubscriptionLabelsRequest) UseCommercialAppName(useCommercialAppName bool) ApiUpsertSubscriptionLabelsRequest {
	r.useCommercialAppName = &useCommercialAppName
	return r
}

func (r ApiUpsertSubscriptionLabelsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpsertSubscriptionLabelsExecute(r)
}

/*
UpsertSubscriptionLabels Assign labels to a multitenant application subscription

Assign user-defined labels to a consumer subaccount's subscription to a multitenant application. Labels are specified as key-value pairs. 

Required scope: $XSAPPNAME.subaccount.application.subscription.update


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param appName The name of the multitenant application to which a subaccount is subscribed.
 @return ApiUpsertSubscriptionLabelsRequest
*/
func (a *SubscriptionOperationsForAppConsumersAPIService) UpsertSubscriptionLabels(ctx context.Context, appName string) ApiUpsertSubscriptionLabelsRequest {
	return ApiUpsertSubscriptionLabelsRequest{
		ApiService: a,
		ctx: ctx,
		appName: appName,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SubscriptionOperationsForAppConsumersAPIService) UpsertSubscriptionLabelsExecute(r ApiUpsertSubscriptionLabelsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionOperationsForAppConsumersAPIService.UpsertSubscriptionLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/applications/{appName}/subscription/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"appName"+"}", url.PathEscape(parameterValueToString(r.appName, "appName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.labelAssignmentRequestPayload == nil {
		return localVarReturnValue, nil, reportError("labelAssignmentRequestPayload is required and must be specified")
	}

	if r.useCommercialAppName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCommercialAppName", r.useCommercialAppName, "form", "")
	} else {
		var defaultValue bool = false
		r.useCommercialAppName = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.labelAssignmentRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
SaaS Provisioning Service

The SAP SaaS Provisioning service provides REST APIs that are responsible for the registration and provisioning of multitenant applications and services.   Use the APIs in this service to perform various operations related to your multitenant applications and services. For example, to get application registration details, subscribe a tenant to your application, unsubscribe a tenant from your application, retrieve all your application subscriptions, update subscription dependencies, and to get subscription job information. Note: \"Application Operations for App Providers\" APIs are intended for maintenance activities, not for runtime flows.  See also: * [Authorization](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/3670474a58c24ac2b082e76cbbd9dc19.html) * [Rate Limiting](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77b217b3f57a45b987eb7fbc3305ce1e.html) * [Error Response Format](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77fef2fb104b4b1795e2e6cee790e8b8.html) * [Asynchronous Jobs](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/0a0a6ab0ad114d72a6611c1c6b21683e.html)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPI interface {

	/*
	SubscriptionCallbackAsync Subscribe a subaccount tenant to an application

	Use the async callback feature to subscribe a subaccount tenant to a multitenant application if a subscription process is time-consuming.<br/><br/>Requires one of the following scopes: $XSAPPNAME.subscription.write or $XSAPPNAME.subscription.service.write

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param identifier Unique identifier of the current subscription job.
	@return ApiSubscriptionCallbackAsyncRequest
	*/
	SubscriptionCallbackAsync(ctx context.Context, identifier string) ApiSubscriptionCallbackAsyncRequest

	// SubscriptionCallbackAsyncExecute executes the request
	//  @return string
	SubscriptionCallbackAsyncExecute(r ApiSubscriptionCallbackAsyncRequest) (string, *http.Response, error)
}

// AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPIService AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPI service
type AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPIService service

type ApiSubscriptionCallbackAsyncRequest struct {
	ctx context.Context
	ApiService AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPI
	identifier string
	saasAsyncSubscriptionRequestPayload *SaasAsyncSubscriptionRequestPayload
}

func (r ApiSubscriptionCallbackAsyncRequest) SaasAsyncSubscriptionRequestPayload(saasAsyncSubscriptionRequestPayload SaasAsyncSubscriptionRequestPayload) ApiSubscriptionCallbackAsyncRequest {
	r.saasAsyncSubscriptionRequestPayload = &saasAsyncSubscriptionRequestPayload
	return r
}

func (r ApiSubscriptionCallbackAsyncRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.SubscriptionCallbackAsyncExecute(r)
}

/*
SubscriptionCallbackAsync Subscribe a subaccount tenant to an application

Use the async callback feature to subscribe a subaccount tenant to a multitenant application if a subscription process is time-consuming.<br/><br/>Requires one of the following scopes: $XSAPPNAME.subscription.write or $XSAPPNAME.subscription.service.write

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identifier Unique identifier of the current subscription job.
 @return ApiSubscriptionCallbackAsyncRequest
*/
func (a *AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPIService) SubscriptionCallbackAsync(ctx context.Context, identifier string) ApiSubscriptionCallbackAsyncRequest {
	return ApiSubscriptionCallbackAsyncRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

// Execute executes the request
//  @return string
func (a *AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPIService) SubscriptionCallbackAsyncExecute(r ApiSubscriptionCallbackAsyncRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AsynchronousCallbackOperationsForSAPAuthorizationAndTrustManagementServiceXSUAAAPIService.SubscriptionCallbackAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saas-manager/v1/subscription-callback/{identifier}/result"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", url.PathEscape(parameterValueToString(r.identifier, "identifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.saasAsyncSubscriptionRequestPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

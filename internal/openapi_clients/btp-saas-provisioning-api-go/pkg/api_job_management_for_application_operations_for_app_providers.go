/*
SaaS Provisioning Service

The SAP SaaS Provisioning service provides REST APIs that are responsible for the registration and provisioning of multitenant applications and services.   Use the APIs in this service to perform various operations related to your multitenant applications and services. For example, to get application registration details, subscribe a tenant to your application, unsubscribe a tenant from your application, retrieve all your application subscriptions, update subscription dependencies, and to get subscription job information. Note: \"Application Operations for App Providers\" APIs are intended for maintenance activities, not for runtime flows.  See also: * [Authorization](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/3670474a58c24ac2b082e76cbbd9dc19.html) * [Rate Limiting](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77b217b3f57a45b987eb7fbc3305ce1e.html) * [Error Response Format](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/77fef2fb104b4b1795e2e6cee790e8b8.html) * [Asynchronous Jobs](https://help.sap.com/viewer/65de2977205c403bbc107264b8eccf4b/latest/en-US/0a0a6ab0ad114d72a6611c1c6b21683e.html)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type JobManagementForApplicationOperationsForAppProvidersAPI interface {

	/*
	GetJobRelatedToSaasApplicationById Get job errorStatusCode

	Get information about the state of the created job.<br/><br/>Required scopes: $XSAPPNAME.job.read

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobUuid The unique ID of a job for which to get information.
	@return ApiGetJobRelatedToSaasApplicationByIdRequest
	*/
	GetJobRelatedToSaasApplicationById(ctx context.Context, jobUuid string) ApiGetJobRelatedToSaasApplicationByIdRequest

	// GetJobRelatedToSaasApplicationByIdExecute executes the request
	//  @return JobStateResponseObject
	GetJobRelatedToSaasApplicationByIdExecute(r ApiGetJobRelatedToSaasApplicationByIdRequest) (*JobStateResponseObject, *http.Response, error)

	/*
	GracefulTerminationJob Graceful termination of an async job

	Graceful terminate the last run of the job with the specified job instance ID. Only jobs with statuses STARTING or STARTED can be stopped. <br/><br/>Required scope: $XSAPPNAME.job.update

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobUuid Id of the async job
	@return ApiGracefulTerminationJobRequest
	*/
	GracefulTerminationJob(ctx context.Context, jobUuid string) ApiGracefulTerminationJobRequest

	// GracefulTerminationJobExecute executes the request
	//  @return string
	GracefulTerminationJobExecute(r ApiGracefulTerminationJobRequest) (string, *http.Response, error)
}

// JobManagementForApplicationOperationsForAppProvidersAPIService JobManagementForApplicationOperationsForAppProvidersAPI service
type JobManagementForApplicationOperationsForAppProvidersAPIService service

type ApiGetJobRelatedToSaasApplicationByIdRequest struct {
	ctx context.Context
	ApiService JobManagementForApplicationOperationsForAppProvidersAPI
	jobUuid string
}

func (r ApiGetJobRelatedToSaasApplicationByIdRequest) Execute() (*JobStateResponseObject, *http.Response, error) {
	return r.ApiService.GetJobRelatedToSaasApplicationByIdExecute(r)
}

/*
GetJobRelatedToSaasApplicationById Get job errorStatusCode

Get information about the state of the created job.<br/><br/>Required scopes: $XSAPPNAME.job.read

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobUuid The unique ID of a job for which to get information.
 @return ApiGetJobRelatedToSaasApplicationByIdRequest
*/
func (a *JobManagementForApplicationOperationsForAppProvidersAPIService) GetJobRelatedToSaasApplicationById(ctx context.Context, jobUuid string) ApiGetJobRelatedToSaasApplicationByIdRequest {
	return ApiGetJobRelatedToSaasApplicationByIdRequest{
		ApiService: a,
		ctx: ctx,
		jobUuid: jobUuid,
	}
}

// Execute executes the request
//  @return JobStateResponseObject
func (a *JobManagementForApplicationOperationsForAppProvidersAPIService) GetJobRelatedToSaasApplicationByIdExecute(r ApiGetJobRelatedToSaasApplicationByIdRequest) (*JobStateResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobStateResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobManagementForApplicationOperationsForAppProvidersAPIService.GetJobRelatedToSaasApplicationById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2.0/jobs/{jobUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUuid"+"}", url.PathEscape(parameterValueToString(r.jobUuid, "jobUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGracefulTerminationJobRequest struct {
	ctx context.Context
	ApiService JobManagementForApplicationOperationsForAppProvidersAPI
	jobUuid string
}

func (r ApiGracefulTerminationJobRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GracefulTerminationJobExecute(r)
}

/*
GracefulTerminationJob Graceful termination of an async job

Graceful terminate the last run of the job with the specified job instance ID. Only jobs with statuses STARTING or STARTED can be stopped. <br/><br/>Required scope: $XSAPPNAME.job.update

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobUuid Id of the async job
 @return ApiGracefulTerminationJobRequest
*/
func (a *JobManagementForApplicationOperationsForAppProvidersAPIService) GracefulTerminationJob(ctx context.Context, jobUuid string) ApiGracefulTerminationJobRequest {
	return ApiGracefulTerminationJobRequest{
		ApiService: a,
		ctx: ctx,
		jobUuid: jobUuid,
	}
}

// Execute executes the request
//  @return string
func (a *JobManagementForApplicationOperationsForAppProvidersAPIService) GracefulTerminationJobExecute(r ApiGracefulTerminationJobRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobManagementForApplicationOperationsForAppProvidersAPIService.GracefulTerminationJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2.0/jobs/{jobUuid}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"jobUuid"+"}", url.PathEscape(parameterValueToString(r.jobUuid, "jobUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

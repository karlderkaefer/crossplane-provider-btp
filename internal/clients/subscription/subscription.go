package subscription

import (
	"context"
	"fmt"
	"strings"

	"github.com/pkg/errors"
	"github.com/sap/crossplane-provider-btp/apis/account/v1alpha1"
	"github.com/sap/crossplane-provider-btp/btp"
	"github.com/sap/crossplane-provider-btp/internal"
	saas_client "github.com/sap/crossplane-provider-btp/internal/openapi_clients/btp-saas-provisioning-api-go/pkg"
	"golang.org/x/oauth2/clientcredentials"
)

// SubscriptionGet generic Get type that could be autogenerated, can be alias of existing client implementations value object
type SubscriptionGet = saas_client.EntitledApplicationsResponseObject

// SubscriptionPost generic Post type that could be autogenerated, here encapsulate existing api client type along with additional appName that is required for POST operation
type SubscriptionPost struct {
	appName string
	saas_client.CreateSubscriptionRequestPayload
}

// SubscriptionPut generic Post type that could be autogenerated, here encapsulate existing api client type along with additional appName that is required for PUT operation
type SubscriptionPut struct {
	appName string
	saas_client.UpdateSubscriptionRequestPayload
}

// SubscriptionApiHandlerI interface that abstracts all API client operations that have to be exposed towards controller
// represents basic Rest CRUD operations
type SubscriptionApiHandlerI interface {
	CreateSubscription(ctx context.Context, payload SubscriptionPost) (string, error)
	UpdateSubscription(ctx context.Context, externalName string, payload SubscriptionPut) error
	DeleteSubscription(ctx context.Context, externalName string) error
	GetSubscription(ctx context.Context, externalName string) (*SubscriptionGet, error)
}

// SubscriptionTypeMapperI interface to encapsulate all domain logic for making the controller work with otherwise unknown API and its types
type SubscriptionTypeMapperI interface {
	// ConvertToCreatePayload maps a given CR to a API Post object (mostly payload, but might include addtional metadata)
	ConvertToCreatePayload(cr *v1alpha1.Subscription) SubscriptionPost
	// ConvertToUpdatePayload maps a given CR to a API Put object (mostly payload, but might include addtional metadata)
	ConvertToUpdatePayload(cr *v1alpha1.Subscription) SubscriptionPut
	// IsUpToDate compares a given CR with the external API representation, returns whether updates towards the API are required or not
	IsUpToDate(cr *v1alpha1.Subscription, get *SubscriptionGet) bool
	// IsAvailable allow additional check for whether a CR is fully available or not, maps to ready condition in controller, might be used for checking an observed API state field
	IsAvailable(cr *v1alpha1.Subscription) bool
	// IsDeletable allow additional check for whether a CR can be deleted or not
	IsDeletable(cr *v1alpha1.Subscription) bool
	// SyncStatus allows to pull some data from external API resource towards the CR status
	SyncStatus(get *SubscriptionGet, crStatus *v1alpha1.SubscriptionObservation)
}

var _ SubscriptionApiHandlerI = &SubscriptionApiHandler{}

// NewSubscriptionApiHandler Creates instance of ApiHandler implementation
func NewSubscriptionApiHandler(ctx context.Context, clientId string, clientSecret string, tokenUrl string, serviceUrl string) *SubscriptionApiHandler {
	c := saas_client.NewConfiguration()

	config := &clientcredentials.Config{
		ClientID:     clientId,
		ClientSecret: clientSecret,
		TokenURL:     tokenUrl,
	}

	//Set a http client that logs the request and response when running in debug
	btp.AddDebugPrintHTTPClientToContext(ctx)

	c.HTTPClient = config.Client(ctx)
	c.Servers = []saas_client.ServerConfiguration{{URL: serviceUrl}}

	return &SubscriptionApiHandler{client: saas_client.NewAPIClient(c)}
}

type SubscriptionApiHandler struct {
	client *saas_client.APIClient
}

func (s *SubscriptionApiHandler) CreateSubscription(ctx context.Context, subPost SubscriptionPost) (string, error) {
	if _, err := s.client.SubscriptionOperationsForAppConsumersAPI.
		CreateSubscriptionAsync(ctx, subPost.appName).
		CreateSubscriptionRequestPayload(subPost.CreateSubscriptionRequestPayload).
		Execute(); err != nil {
		return "", specifyAPIError(err)
	}

	return formExternalName(subPost.appName, internal.Val(subPost.PlanName)), nil
}

func (s *SubscriptionApiHandler) UpdateSubscription(ctx context.Context, externalName string, subPut SubscriptionPut) error {
	appName, _ := splitExternalName(externalName)

	if _, err := s.client.SubscriptionOperationsForAppConsumersAPI.
		UpdateSubscriptionParametersAsync(ctx, appName).
		UpdateSubscriptionRequestPayload(subPut.UpdateSubscriptionRequestPayload).
		Execute(); err != nil {
		return specifyAPIError(err)
	}
	return nil
}

func (s *SubscriptionApiHandler) DeleteSubscription(ctx context.Context, externalName string) error {
	appName, _ := splitExternalName(externalName)

	if _, err := s.client.SubscriptionOperationsForAppConsumersAPI.
		DeleteSubscriptionAsync(ctx, appName).
		Execute(); err != nil {
		return specifyAPIError(err)
	}
	return nil
}

func (s *SubscriptionApiHandler) GetSubscription(ctx context.Context, externalName string) (*SubscriptionGet, error) {
	appName, planName := splitExternalName(externalName)

	res, raw, err := s.client.SubscriptionOperationsForAppConsumersAPI.
		GetEntitledApplication(ctx, appName).
		PlanName(planName).
		Execute()
	if err != nil {
		return nil, specifyAPIError(err)
	}

	// for any reason right now the api actually returns 429 as not found, will
	if raw.StatusCode == 404 || raw.StatusCode == 429 {
		return nil, nil
	}

	// if an app has been subscribed once in an subaccount it will be present in the api, but with a Not subscribed state
	if res != nil && res.State != nil && *res.State == v1alpha1.SubscriptionStateNotSubscribed {
		return nil, nil
	}

	return res, nil
}

var _ SubscriptionTypeMapperI = &SubscriptionTypeMapper{}

func NewSubscriptionTypeMapper() *SubscriptionTypeMapper {
	return &SubscriptionTypeMapper{}
}

type SubscriptionTypeMapper struct {
}

func (s *SubscriptionTypeMapper) IsAvailable(cr *v1alpha1.Subscription) bool {
	state := cr.Status.AtProvider.State
	return state != nil && *state == v1alpha1.SubscriptionStateSubscribed
}

func (s *SubscriptionTypeMapper) IsDeletable(cr *v1alpha1.Subscription) bool {
	if state := cr.Status.AtProvider.State; state != nil {
		switch *state {
		case v1alpha1.SubscriptionStateSubscribed, v1alpha1.SubscriptionStateSubscribeFailed:
			return true
		}
	}
	return false
}

func (s *SubscriptionTypeMapper) SyncStatus(get *SubscriptionGet, crStatus *v1alpha1.SubscriptionObservation) {
	crStatus.State = get.State
}

func (s *SubscriptionTypeMapper) ConvertToCreatePayload(cr *v1alpha1.Subscription) SubscriptionPost {
	return SubscriptionPost{
		appName: cr.Spec.ForProvider.AppName,
		CreateSubscriptionRequestPayload: saas_client.CreateSubscriptionRequestPayload{
			PlanName:           &cr.Spec.ForProvider.PlanName,
			SubscriptionParams: s.ConvertToClientParams(cr),
		},
	}
}

func (s *SubscriptionTypeMapper) ConvertToClientParams(cr *v1alpha1.Subscription) map[string]interface{} {
	subscriptionParams, err := internal.UnmarshalRawParameters(cr.Spec.ForProvider.SubscriptionParameters.DeepCopy().Raw)
	if err != nil {
		return nil
	}

	return subscriptionParams
}

func (s *SubscriptionTypeMapper) ConvertToUpdatePayload(cr *v1alpha1.Subscription) SubscriptionPut {
	panic("currently not supported")
}

func (s *SubscriptionTypeMapper) IsUpToDate(cr *v1alpha1.Subscription, get *SubscriptionGet) bool {
	// currently no updates are supported
	return true
}

// splitExternalName splits an externalName into its to part, requires form <appName>/<planName>, returns segments as empty strings, does not protect against misusage
func splitExternalName(externalName string) (string, string) {
	fragments := strings.Split(externalName, "/")
	return fragments[0], fragments[1]
}

// formExternalName combines appName and planName into a single string of the form <appName>/<planName>
func formExternalName(appName string, planName string) string {
	return strings.Join([]string{appName, planName}, "/")
}

// specifyAPIError brings custom API Error object into a string representation if it can be type asserted, otherwise returns given error
func specifyAPIError(err error) error {
	if genericErr, ok := err.(*saas_client.GenericOpenAPIError); ok {
		if saasErr, ok := genericErr.Model().(saas_client.ErrorResponse); ok {
			return errors.New(fmt.Sprintf("API Error: %v, Code %v", saasErr.Error.Message, saasErr.Error.Code))
		}
	}
	return err
}
